package io.github.darvld.wireframe

import graphql.schema.*
import graphql.schema.idl.RuntimeWiring
import graphql.schema.idl.SchemaGenerator
import graphql.schema.idl.SchemaParser
import graphql.schema.idl.TypeDefinitionRegistry
import io.github.darvld.wireframe.WireframeCompilerPlugin.Output
import io.github.darvld.wireframe.analysis.*
import io.github.darvld.wireframe.extensions.buildFile
import io.github.darvld.wireframe.extensions.isRouteType
import io.github.darvld.wireframe.generation.buildSpec
import io.github.darvld.wireframe.model.*

/**Analyzes `.graphqls` schema definitions using graphql-java and outputs type-safe Kotlin code for the types and
 *  operations in the schema.*/
public class WireframeCompiler {
    /**Analyzes the provided GraphQL schema sources and collects necessary data for code generation in the target package.*/
    public fun analyze(packageName: String, sources: List<String>): GenerationEnvironment {
        val parser = SchemaParser()

        // Parse all sources and merge declarations into a single registry
        val registry: TypeDefinitionRegistry = sources.fold(TypeDefinitionRegistry()) { current, next ->
            current.merge(parser.parse(next))
        }

        // Create a schema with an empty wiring, this allows us to analyze the schema generated by graphql-java
        val schema: GraphQLSchema = SchemaGenerator().makeExecutableSchema(
            /* typeRegistry = */ registry,
            /* wiring = */ RuntimeWiring.newRuntimeWiring().build()
        )

        val inputTypes = mutableSetOf<InputDTO>()
        val outputTypes = mutableSetOf<OutputDTO>()
        val enumTypes = mutableSetOf<EnumDTO>()
        val routes = mutableSetOf<RouteData>()

        for (type: GraphQLNamedType in schema.allTypesAsList) when {
            type.ignoreForAnalysis() -> continue
            type.isRouteType() -> routes.addAll(processRouteType(type))
            type is GraphQLEnumType -> enumTypes.add(processEnumType(type, packageName))
            type is GraphQLInputObjectType -> inputTypes.add(processInputType(type, packageName))
            type is GraphQLObjectType -> {
                outputTypes.add(processOutputType(type, packageName))
                routes.addAll(processExtensionRoutes(type))
            }
        }

        return GenerationEnvironment(
            packageName,
            inputTypes,
            outputTypes,
            enumTypes,
            routes,
        )
    }

    /**Generate type-safe Kotlin DTOs and mappers for input and output types, and route handler extensions for queries,
     *  mutations and subscriptions.
     *
     * A pseudo-constructor will be generated for each input type, taking a `Map<String, Any?>` as its only parameter,
     * to enable conversion from graphql-java's map-based input schemas.
     *
     * The returned sequence triggers the actual code generation when collected.*/
    public fun generate(
        environment: GenerationEnvironment,
        plugins: List<WireframeCompilerPlugin> = emptyList(),
    ): Sequence<Output> = with(environment) {
        val pluginsSequence = plugins.fold(emptySequence<Output>()) { seq, it ->
            seq + it.processEnvironment(environment)
        }

        return sequence {
            for (inputDTO in inputTypes) yield(buildFile(inputDTO.name) {
                addType(inputDTO.buildSpec(environment))
            })

            for (outputDTO in outputTypes) yield(buildFile(outputDTO.name) {
                addType(outputDTO.buildSpec(environment))
            })

            for (enum in enumTypes) yield(buildFile(enum.name) {
                addType(enum.buildSpec())
            })
        }.map(::Output) + pluginsSequence
    }
}