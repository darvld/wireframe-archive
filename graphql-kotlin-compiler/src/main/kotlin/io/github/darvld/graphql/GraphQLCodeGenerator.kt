package io.github.darvld.graphql

import com.squareup.kotlinpoet.FileSpec
import graphql.schema.*
import graphql.schema.idl.RuntimeWiring
import graphql.schema.idl.SchemaGenerator
import graphql.schema.idl.SchemaParser
import graphql.schema.idl.TypeDefinitionRegistry
import io.github.darvld.graphql.extensions.buildFile
import io.github.darvld.graphql.extensions.isRouteType
import io.github.darvld.graphql.extensions.pack
import io.github.darvld.graphql.generation.*
import io.github.darvld.graphql.model.GenerationEnvironment
import java.nio.file.Path

/**Analyzes `.graphqls` schema definitions using graphql-java and outputs type-safe Kotlin code for the types and
 *  operations in the schema.*/
public class GraphQLCodeGenerator {

    /**Encapsulates an output element from the code generator. Use it to write the generated code to an [Appendable],
     * or as a file in a target directory.*/
    @JvmInline
    public value class Output internal constructor(private val spec: FileSpec) {
        public val name: String
            get() = spec.name

        public val packageName: String
            get() = spec.packageName

        public fun writeTo(directory: Path) {
            spec.writeTo(directory)
        }

        public fun writeTo(out: Appendable) {
            spec.writeTo(out)
        }
    }

    /**Generate type-safe Kotlin DTOs and mappers for input and output types, and route handler extensions for queries,
     *  mutations and subscriptions.
     *
     * A pseudo-constructor will be generated for each input type, taking a `Map<String, Any?>` as its only parameter,
     * to enable conversion from graphql-java's map-based input schemas.
     *
     * The returned sequence triggers the actual code generation when collected.*/
    public fun generate(
        packageName: String,
        sources: List<String>,
    ): Sequence<Output> {
        val parser = SchemaParser()

        // Parse all sources and merge declarations into a single registry
        val registry: TypeDefinitionRegistry = sources.fold(TypeDefinitionRegistry()) { current, next ->
            current.merge(parser.parse(next))
        }

        // Create a schema with an empty wiring, this allows us to analyze the schema generated by graphql-java
        val schema: GraphQLSchema = SchemaGenerator().makeExecutableSchema(
            /* typeRegistry = */ registry,
            /* wiring = */ RuntimeWiring.newRuntimeWiring().build()
        )

        // Process all types in the schema and generate the output sequence
        val environment = GenerationEnvironment(packageName)
        return schema.allTypesAsList.asSequence().mapNotNull { type ->
            environment.generateType(type)
        }.map(::Output)
    }

    private fun GenerationEnvironment.generateType(type: GraphQLNamedType): FileSpec? {
        // Ignore internal type definitions. This excludes introspection types and handlers
        if (type.name.startsWith("_")) return null

        // Query, Mutation, and Subscription are top-level objects used to define operations
        if (type is GraphQLObjectType && type.isRouteType()) {
            return generateRouteHandlers(type).pack(packageName, type.name)
        }

        return when (type) {
            is GraphQLEnumType -> {
                generateEnumType(type).pack(packageName)
            }
            is GraphQLObjectType -> {
                generateOutputType(type).pack(packageName)
            }
            is GraphQLInputObjectType -> buildFile(type.name) {
                addType(generateInputType(type))
                addFunction(generateInputDecoder(type))
            }
            else -> null
        }
    }
}