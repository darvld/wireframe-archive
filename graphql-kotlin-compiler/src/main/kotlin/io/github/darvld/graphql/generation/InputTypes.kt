package io.github.darvld.graphql.generation

import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.KModifier.DATA
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import io.github.darvld.graphql.extensions.*
import io.github.darvld.graphql.mapping.InputMapper
import io.github.darvld.graphql.model.GenerationEnvironment
import io.github.darvld.graphql.model.InputDTO

/**Builds a [TypeSpec] from this input DTO's type data.*/
internal fun InputDTO.buildSpec(environment: GenerationEnvironment): TypeSpec = buildClass(generatedType) {
    addModifiers(DATA)

    markAsGenerated()
    addKdoc(definition.description.orEmpty())

    primaryConstructor(buildConstructor {
        for (field in definition.fields) {
            val fieldTypeName = field.type.typeName(environment.packageName)
            val property = PropertySpec.builder(field.name, fieldTypeName)
                .addKdoc(field.description.orEmpty())
                .initializer(field.name)
                .build()

            addParameter(field.name, fieldTypeName)
            addProperty(property)
        }
    })
}

/**Generates a [FunSpec] that allows constructing this DTO from unsafe maps (as generated by graphql-java).*/
internal fun InputDTO.buildDecoder(
    environment: GenerationEnvironment,
): FunSpec = buildFunction(generatedType.simpleName) {
    markAsGenerated()
    addKdoc("Constructs a new $name from an unsafe map. This is useful for decoding the query parameters provided by graphql-java.")

    returns(generatedType)
    addParameter("map", MAP.parameterizedBy(STRING, ANY.nullable()))

    addCode(buildCodeBlock {
        add("return路%T(\n", generatedType)
        indent()

        for (field in definition.fields) {
            val extractor = environment.buildFieldExtractor(
                extractor = { CodeBlock.of("map[%S]路as路%T", field.name, it) },
                fieldType = field.type,
            )

            addStatement("%L = %L,", field.name, extractor)
        }

        unindent()
        add(")\n")
    })
}

/**Generates a [TypeSpec] describing an [InputMapper] for this DTO. This allows to translate from the business layer's
 * input to, for example, a MongoDB document structure.*/
internal fun InputDTO.buildMapper(environment: GenerationEnvironment): TypeSpec {
    val mapperName = ClassName(generatedType.packageName, name.removeSuffix("DTO") + "Mapper")

    return buildClass(mapperName) {
        superclass(INPUT_MAPPER)

        markAsGenerated()
        addKdoc("An [InputMapper] that can be used to convert [$name] instances to other formats.")

        primaryConstructor(buildConstructor {
            definition.fields.forEach {
                val fieldTypeName = INPUT_TRANSFORM.parameterizedBy(it.type.typeName(environment.packageName))

                addParameter(ParameterSpec.builder(it.name, fieldTypeName).build())
                addProperty(PropertySpec.builder(it.name, fieldTypeName).initializer(it.name).build())
            }
        })

        addFunction(buildFunction("map") {
            addParameter("input", generatedType)
            addParameter("target", MAPPING_TARGET)

            beginControlFlow("return with(target)路{")
            definition.fields.forEach {
                addStatement("set(%L, input.%L)", it.name, it.name)
            }
            endControlFlow()
        })
    }
}