package io.github.darvld.graphql.generation

import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.KModifier.DATA
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import io.github.darvld.graphql.extensions.*
import io.github.darvld.graphql.model.GenerationEnvironment
import io.github.darvld.graphql.model.InputDTO

/**Builds a [TypeSpec] from this input DTO's type data.*/
internal fun InputDTO.buildSpec(environment: GenerationEnvironment): TypeSpec = buildClass(generatedType) {
    addModifiers(DATA)

    primaryConstructor(buildConstructor {
        definition.fields.forEach {
            val fieldTypeName = it.type.typeName(environment.packageName)

            addParameter(ParameterSpec.builder(it.name, fieldTypeName).build())
            addProperty(PropertySpec.builder(it.name, fieldTypeName).initializer(it.name).build())
        }
    })
}

/**Generates a [FunSpec] that allows constructing this DTO from unsafe maps (as generated by graphql-java).*/
internal fun InputDTO.buildDecoder(
    environment: GenerationEnvironment,
): FunSpec = buildFunction(generatedType.simpleName) {
    returns(generatedType)
    addParameter("map", MAP.parameterizedBy(STRING, ANY.nullable()))

    addCode(buildCodeBlock {
        add("return·%T(\n", generatedType)
        indent()

        for (field in definition.fields) {
            val extractor = environment.buildFieldExtractor(
                extractor = { CodeBlock.of("map[%S]·as·%T", field.name, it) },
                fieldType = field.type,
            )

            addStatement("%L = %L,", field.name, extractor)
        }

        unindent()
        add(")\n")
    })
}